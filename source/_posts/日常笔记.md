---
title: 日常笔记
---

- https://help.aliyun.com/document_detail/31827.htm?spm=a2c4g.11186623.0.0.13f54fcaaz05gI#concept-izx-fmt-tdb

- url 传值 带加号 + 可以使用 2B%
- 遵循 RFC4648 编码，URL 和文件名安全，不包含 base64 内所解析的+和/,被传统文本搜索/索引工具视为分词符

- Hooks can only be called inside the body of a function component. 非法调用 hook。如果 react render 与被 render 组件内的 hook 不是同一个 react 树的话会存在问题。会出现此错误
- 解决方式将被 render 组件与组件内 使用同一个 react 和 react dom https://blog.csdn.net/tangding12/article/details/118496299

- styled-components 原理/用法 @TODO:

```js
import styled from "styled-components";
const H5SearchInput = styled(Input).attrs({
  size: "m",
})``;
```

- whistle 基于 node 实现的跨平台 web 调试代理工具。很好的 mock 工具 http://wproxy.org/whistle/

- 快速构建 react 组件库 https://cloud.tencent.com/developer/news/686597

- 前端微应用(阿里) https://garfish.top/guide/develop/from-zero

- tsup 统一捆绑 typescript https://tsup.egoist.sh/#typescript

- 现代包管理器 https://developer.51cto.com/art/202102/647082.htm?pc

## 2021.11.02

- e.preventDefault()

## 2021.11.03

- 心得：根据 styled props 控制样式展示
- 写工具、公用方法、组件库 暴露类型定义、方法。这样写的好处，即可引入主包时进行 解构 ，使用指定组件时可以默认导出

  ```js
  export default Anchor;
  export * from "./types";
  export { Anchor };
  ```

- lerna 包管理器 学习一下

- njk 模版引擎学习下

## 2021.11.08

- 1.双飞翼布局(圣杯布局)
- 2.假等高 padding 和 margin

## 2021.11.06 技术分享会

- 分布式软件交付困局
  Docker
  Kuberenetes
  Helm

- 什么是集群镜像 分布式应用 Sealer
- 前端 微应用 k8s 发布互不影响

- 流量前端控制

什么是 Impersonate ?
动态 SNI 证书
ApiServer

- 混沌工程 chaos mesh

- lodash 打包不支持 treeshaking，可通过 babel 和 lodash-es 解决
- nano css hint

```json
  {
    "devServer": {
    "onAfterSetupMiddleware": (devServer){
            // mock数据
            devServer.app.get('/some/path', function (req, res) {
                res.json({ custom: 'response' });
            });
        }
    }
  }

```

函数式编程

https://jiapan.me/2020/multi-repo-vs-mono-repo/

单体应用和维服务应用

## 2021-11-09

- styled-components 与 styleName 和 style 有什么关系

  - css modules
    ```js
    /** 
        1.使用css module如果引入不存在class也不会报错
        2.style对象形式展示
        3.不可使用原 连字符的形式书写，需要小驼峰形式
      */
    import style from "./style.modules.css";
    // ... JSX ...
    let Test = () => <div className={style.test}>test text</div>;
    // ... JSX ...
    export default Test;
    ```
  - 为了解决 css module 以上问题，react-css-module 应运而生

    - react-css-module 仍存在缺点，该插件在运行时编译的，在虚拟 DOM 的生成中修改了 className,这样会对客户端的性能造成一定损耗

    ```js
    import style from "./style.modules.css";
    import CssModule from "react-css-modules";
    // ... JSX ...
    let Test = () => <div className="test">test text</div>;
    // ... JSX ...
    export default CssModule(style, Test);
    ```

  - 为了解决 react-css-module 面临的问题, babel-plugin-react-css-modules 应运而生
    - babel-plugin-react-css-modules 借助 Babel 可以让 React 应用在构建时就直接替换掉 className 中的值，这样就会极高的提升性能
    - 同时为了与 className 不冲突，babel-plugin-react-css-modules 规定了如果是引用 CSS Modules 中的 class 的话，可以使用 styleName 来进行样式的定义
    ```js
    import "./style.module.css";
    let Test = () => <div styleName="test">test text</div>;
    export default Test;
    ```

- styled-components 不支持 css 和 less、scss 看量

- git cz 工具，多人协作的项目中，git 提交说明精准嘛，后期写作以及 BUG 处理会变得有据可查

- react 更新机制原理

## 2021-11-11

- ReactDOM - ReactDOM.render()：
- React.unmountComponentAtNode 做什么用的～
- new Error('canceled') 使用 new Error 抛出错误

- delete

## 2021-11-12

- webpack 原理、loader、plugins 如何编写

- loader-utils

```js
// loader 模块是一个
const { urlToRequest } = require("loader-utils");
const { validate } = require("schema-utils");

const schema = {
  type: "object",
  properties: {
    test: {
      type: "string",
    },
  },
};

module.exports = function (source) {
  const options = this.getOptions();

  validate(schema, options, {
    name: "Example Loader",
    baseDataPath: "options",
  });

  console.log("The request path", urlToRequest(this.resourcePath));

  // Apply some transformations to the source...

  return `export default ${JSON.stringify(source)}`;
};
```

- 知道为什么会出现.mjs 和 js 吗、两者区分

  - 与 js 模块相关，在 v8 引擎更推荐以 .mjs 表示为 js 模块
  - 在目前看来.mjs 兼容性并不太好，对于用来写 demo、测试可以这么做。建议还是以.js 为主
  - 如果开发使用 .mjs 后缀名方式的话，可以通过打包将.mjs 转换成.js
  - 为了使模块能够正常的在浏览器使用，服务器应确保能够处理 Content-type 头，其包含 javascript MINE 类型 text/javascript 。在很多服务器中不支持处理 .mjs 文件

- mj-tool \ mj-matting 美间老工具

## 2021-11-13

- 微应用加载器
- https://developer.aliyun.com/article/755252
- 面试 https://juejin.cn/post/6987549240436195364
- 松本行弘的程序世界 - 书籍

# 2021-11-17

- 浏览器相对路径、绝对路径 例如 axios 中的 baseURL
- rsa 非对称加密，需要将 authTag 一起拼接起来

# 2021-11-19

- https://mp.weixin.qq.com/s?__biz=MzkzMjIxNTcyMA==&mid=2247488919&idx=1&sn=2b4710d9087be3218cc271799de1cec1&scene=21&kpm=qkWL.85a576dbd032bacc.93ee5c2.1637287114876&version=3.1.19.90358&platform=mac#wechat_redirect

- https://segmentfault.com/a/1190000022631614

- https://github.com/umijs/qiankun/blob/8a284bb1263bc63945fd29d76ee092554a70c847/src/apis.ts

- https://juejin.cn/post/6844903848939634696

- git 操作、回滚

- vue api 源码，可以通过 defineProperty 重新定义对象的 get 和 set，对其做一定的限制
  const configDef = {}
  configDef.get = () => config
  if (process.env.NODE_ENV !== 'production') {
  configDef.set = () => {
  warn(
  'Do not replace the Vue.config object, set individual fields instead.'
  )
  }
  }
  Object.defineProperty(Vue, 'config', configDef)

## 2021-11-25

- https://doc.xuwenliang.com/docs/tool/3659 通过 docz 编写 组件文档

## 2021-11-26

- tapable

- react fiber

- https://swc.rs/docs/configuration/compilation

- https://www.typescriptlang.org/docs/handbook/2/conditional-types.html

## 2021-11-29

- react-css-modules

  ```js
  {
    plugins: [
      "react-css-modules",
      {
        context: srcPath,
        exclude: "node_modules",
        autoResolveMultipleImports: true,
        webpackHotModuleReloading: true, // 编辑less文件支持热更新
        filetypes: {
          ".less": {
            syntax: "postcss-less",
            plugins: ["postcss-nested"], // 支持 连体符(嵌套)
          },
        },
        generateScopedName,
      },
    ];
  }
  // 如果使用 react-css-modules 语法上不支持 postcss-nested 例如
  /**
   *
      .wrap {
        &-jk{
          color: red
        }
      }
  
   */
  ```

- 业务微应用，可通过 micro

- 为什么在 monorepo 单一仓库模式下，没有依赖的包会提示错误，一旦被有依赖的包引入后，源文件提示错误就会消失

## 2021-11-30

- import 微应用 挂在 window 下

  ```js
  {
    externals: [
      function (ctx, callback) {
        const { request } = ctx;
        // 引入 @pub/meijian-meijian-micros-site-base 微应用时，读取的是window上的内容，如果项目引用某个微应用时，可以通过这个正则去匹配，读取window上指定引用的微应用
        if (/^@pub\/(.*)+$/.test(request)) {
          return callback(null, [request], "window");
        }
        // Continue without externalizing the import，排除当前非外部 import
        callback();
      },
    ];
  }
  // window
  /**
   *
    /***/ "@pub/meijian-meijian-micros-site-base":
    /*!**********************************************************!*\
      !*** external "@pub/meijian-meijian-micros-site-base" ***!
      \**********************************************************/
    /***/ (function(module) {
      module.exports = window["@pub/meijian-meijian-micros-site-base"];
    /***/ })
   */

  ```

- kjl 套件 监听文件变化，自动写入微应用套件

## 2021-12-01

- 监听浏览器拦截

  ```js
  // 浏览器刷新
  window.addEventListener("beforeunload", handleBeforeunload);

  return () => {
    unblock && unblock();
    window.removeEventListener("beforeunload", handleBeforeunload);
  };
  ```

- 监听 react 路由拦截跳转

  ```js
  import { useHistory, useLocation } from "react-router-dom";
  const history = useHistory();
  // block 注册路由监听事件
  const unblock = history.block((nextLocation, action) => {
    if (!isDataEqual()) {
      Modal.confirm({
        title: "提示",
        icon: <ExclamationCircleOutlined />,
        content: "当前内容未保存是否要离开？",
        okText: "确认",
        cancelText: "取消",
        onOk() {
          unblock && unblock();
          if (action === "PUSH") {
            history.push(nextLocation);
          } else if (action === "POP") {
            history.goBack();
          } else if (action === "REPLACE") {
            history.replace(nextLocation);
          }
        },
      });
      return false; // 阻止react路由跳转
    } else {
      unblock && unblock(); // 注销react路由拦截
    }
  });
  ```

- 字符串 "undefined" 如果变成 undefined ，这个问题是由 url 解析时产生的问题，url 解析后出来的是字符串

## 2021-12-02
